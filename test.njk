<!DOCTYPE html>
<html>

<body>
    <h1>w00t</h1>
    <span id="theMessage"></span>
</body>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
<script type="text/javascript">
/*
    added a style to the disbled button


*/

//globals
let user; //hold the user details
let amount=0; //hold the amount of crypto they want to buy
let tokenPrice = 0.1; // token price in usd
let redirectUrl = ""; // hold the redcirect URL
let theCurrency = ""; //hold the currency.
let currentAccount = "";
let walletConnected = 0

// stores the users private key if they're not using a web3 injecting wallet such as Metamask
//note (chris) we should just use metamask.
let privateKey = "";
let tempHardcodedPrivKey = "<ADD PRIVATE KEY HERE>";

let web3 = new Web3(Web3.givenProvider || "https://data-seed-prebsc-1-s2.binance.org:8545/");

let showPassword = (el) => {
  let x = document.getElementById(el);
  if (x.type === "password") {
    x.type = "text";
    document.getElementById(el+"-open").classList.add('d-none');
    document.getElementById(el+"-close").classList.remove('d-none');
  } else {
    x.type = "password";
    document.getElementById(el+"-open").classList.remove('d-none');
    document.getElementById(el+"-close").classList.add('d-none');
  }
}



// checks every time a block header has been added
web3.eth.subscribe('newBlockHeaders', async function(error, result) {
    if(typeof setAmount !== "undefined") {
        await setAmount();
    }
});

async function getBlockNumber() {
    const latestBlockNumber = await web3.eth.getBlockNumber();
    return latestBlockNumber;
}

const getAllowance = async (currency, abi, spendingAddress) => {
    console.log("Current Account " + currentAccount);
    if(!web3.utils.isAddress(currentAccount)) return "0";

    let contract = new web3.eth.Contract(abi, currencies[currency].contract);
    return contract.methods.allowance(currentAccount, spendingAddress).call().then(function(res) {
        return web3.utils.fromWei(res, 'ether');
    });
}

const getTokenBalance = async (currency, abi) => {
    if(!web3.utils.isAddress(currentAccount)) return "0";
    if(currency === "") return "0";

    if(currency === "bnb") {
        return web3.utils.fromWei(await web3.eth.getBalance(currentAccount), 'ether');
    }
    
    let contract = new web3.eth.Contract(abi, currencies[currency].contract);
    return contract.methods.balanceOf(currentAccount).call().then(function(res) {
        return web3.utils.fromWei(res, 'ether');
    });
}

const getTotalSupply = async (currency, abi) => {
    if(currency === "") return "0";
    if(currency === "bnb") return "0";

    let contract = new web3.eth.Contract(abi, currencies[currency].contract);
    return contract.methods.totalSupply().call().then(function(res) {
        return web3.utils.fromWei(res, 'ether');
    });
}

const ethEnabled = async () => {
    console.log("Connecting to Web3 Wallet!");
    if(!window.ethereum) {
        // Prompt user to install MetaMask or use UKC account wallet
        console.log("MetaMask is not installed!");
        return false;
    }

    try {
        await switchNetwork();

        currentAccount = await getAccounts();
        console.log(">> " + currentAccount);

        if (window.ethereum) {
            await window.ethereum.send('eth_requestAccounts');
            window.web3 = new Web3(window.ethereum);
            return true;
        }
    } catch(e) {
        console.log(e);
    }

    return false;
}

if(window.ethereum) {
    window.ethereum.on("connect", async connectInfo => {
        console.log(connectInfo);

        currentAccount = await getAccounts();
        console.log(">> " + currentAccount);
    });

    window.ethereum.on("accountsChanged", async accounts => {
        console.log("Account changed to " + accounts[0]);

        if(accounts[0] === undefined) {
            if(loggedIn && privateKey !== "") {
                console.log("Switch to using UKC Web Wallet");
                privateKey = tempHardcodedPrivKey;
            }
        }

        if(typeof setButtonState !== undefined) {
            setButtonState(0);
        }
        await switchNetwork();
        if (accounts.length > 0) currentAccount = accounts[0];
        else currentAccount = "";
    });
}

const switchNetwork = async () => {
    if(window.ethereum === undefined) {
        console.log("No MetaMask");
        return false;
    }

    try {
        await ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x61' }],
        });
      } catch (switchError) {
          console.log(switchError);
        // This error code indicates that the chain has not been added to MetaMask.
        if (switchError.code === 4902 || switchError.code === 32603) {
          try {
            await ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{ 
                    chainId: '0x61', 
                    chainName: "BSC Testnet", 
                    nativeCurrency: {
                        name: "BNB",
                        symbol: "BNB",
                        decimals: 18
                    }, 
                    rpcUrls: ['https://data-seed-prebsc-1-s1.binance.org:8545/'],
                    blockExplorerUrls: ['https://testnet.bscscan.com/']
                }],
            });
          } catch (addError) {
            // handle "add" error
            return false;
          }
        }
      }
    return true;
}

const getAccounts = async () => {
    account = "";
    if(privateKey === "") {
        account = await web3.eth.getAccounts((error, result) => {
            if (error) {
                console.log(error);
            } else {
                return result;
            }
        });
    } else {
        let result = await web3.eth.accounts.privateKeyToAccount(privateKey);
        account = result.address;
        return account;
    }

    return account[0];
}

const isConnected = async () => {
    let conn = false;

    if(!window.ethereum) {
        return false;
    }

    currentAccount = await getAccounts();
    console.log(currentAccount);
    if(currentAccount === undefined) {
        conn = false;
    } else {
        conn = true;
    }

    if(!web3.currentProvider.isMetaMask) {
        conn = false;
        web3 = new Web3("https://data-seed-prebsc-1-s2.binance.org:8545/");
    } else {
        web3 = new Web3(Web3.givenProvider);
    }

    //console.log(currentAccount);
    walletConnected = conn
    return conn;
}

const loadABI = (path) => {
    return $.ajax({type: "GET", url: path, async: false}).responseText;
}




//this function makes the XHR calls.
let xhrcall = (type = 1, method,bodyObj="",setHeader="",redirectUrl="", callback = '') => {
    //debug
    //console.log(apiUrl)
    //console.log(bodyObj)
    //console.log(method)
    //console.log(callback)

    let url = apiUrl+method;

    //store the type
    let xhrtype = '';
    switch(type) {
        case 0:
            xhrtype = 'POST';
            break;
        case 1:
            xhrtype = 'GET';
            break;
        case 2:
            xhrtype = 'PATCH';
            break;
        case 3:
            xhrtype = 'DELETE';
            break;
        case 4:
            xhrtype = 'PUT';
            break;
        default:
            xhrtype = 'GET';
            break;
    }

    //set the new http request
    let xhr = new XMLHttpRequest();
    xhr.open(xhrtype, url);

    //set the header if required
    //note (chris) this may have to be a switch
    if (setHeader == "json")
        xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
    //send the body object if one was passed
    if(bodyObj !== '') {
        xhr.send(bodyObj);
    } else {
        xhr.send();
    }
    //result
    //todo (chris) make this eval back to a done function
    xhr.onload = function() {
        //check if its an error
        if (xhr.status == 400)
        {
            //process the response
            let res = xhr.response;
            res = JSON.parse(res)
            //get the message
            //note (chris) we could tie this in to the site in a nicer way by using the existing error classes we have.
            alert(res.message[0].messages[0].message)
        }
        //check if it was ok.
        if (xhr.status == 200)
        {
            //check if a redirecr url as passed.
            if (redirectUrl != "")
            {
                window.location = redirectUrl
            }
            else
            {
                eval(callback(xhr));
            }

        }            
    
    }
};



//this function checks for preset paramaters and sets them in the get uk coin widget
let checkforParamaters = () => {
    //note (chris) this is a nice to have but it would mean replacing the custom dropdown so we may just not bother.
    return;
    //todo (chris) : get these from local storage
    //amount = 100;
    //theCurrency = "bnb"
    if ((amount != 0) && (theCurrency != ""))
    {
        document.getElementById('inp-currency-amount').value = amount;

        /*
        we would like to set this on load but not sure how to do it.
        let sel = document.getElementById('dd-select-currency');
        console.log(sel)
        var opts = sel.options;
        for (var opt, j = 0; opt = opts[j]; j++) {
          if (opt.value == theCurrency) {
            sel.selectedIndex = j;
            break;
          }
        }
        */
        //setAmount();
    }
}

//this fucntion validates an email address.
let validateEmail = (email) => {
  const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(email);
};


//this function gets the url paramaters
let getUrlParams = () => {
    var url_string = (window.location.href).toLowerCase();
    var url = new URL(url_string);
    if (url.searchParams.get("url") != null)
        redirectUrl = "/"+url.searchParams.get("url")+"/";
    else
        redirectUrl = ""; 
    //console.log("url:"+redirectUrl);
}


//this function checks if the user is logged in.
let loggedIn = () => {
    if (window.localStorage.user)
    {
        let user = JSON.parse(window.localStorage.user);
        if (user.loggedin == 1)
            return true;
        else
            return false;
    }
    else
    {
        return false;    
    }
}



//this function fires on load and set the state of the site based on the users login credentials. 
let checkLogin = () => {
    //check if we have to set paramaters
    if ((window.location.pathname == "/") || (window.location.pathname == "/get-ukc-coin/"))
    {
       checkforParamaters()
    }
    
    //check the URL 
    //console.log( window.location)
    if ((window.location.pathname == "/create-account/") || (window.location.pathname == "/login/"))
    {
        window.location = '/get-ukc-coin/'
    }
    else
    {
        user = JSON.parse(window.localStorage.user);
        if (user.loggedin == 1)
            return true;
        else
            return false;
    }
}

//this function cgecks if a wallet is connected
let checkWallet = () => {
     user = JSON.parse(window.localStorage.user);
     if (user.walletconnected == 1)
        return true;
    else
        return false;
}

   
//add a ready function
let whenDocumentReady = (f) => {
    /in/.test(document.readyState) ? setTimeout('whenDocumentReady(' + f + ')', 9) : f()
}

whenDocumentReady(isReady = () => {
     let res2 = isConnected(); //checkWallet();
});




</script>

</html>